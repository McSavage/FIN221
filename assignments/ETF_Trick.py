{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7ad06f92",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from typing import List, Tuple, Optional, Union\n",
    "from collections import deque\n",
    "\n",
    "class FinancialBars:\n",
    "    \"\"\"\n",
    "    Implementation of tick, volume, and dollar bars from \n",
    "    \"Advances in Financial Machine Learning\" by Marcos LÃ³pez de Prado\n",
    "    \n",
    "    Includes ETF trick for futures roll adjustment\n",
    "    \"\"\"\n",
    "    \n",
    "    def __init__(self, threshold: Union[int, float]):\n",
    "        \"\"\"\n",
    "        Initialize the bar sampler\n",
    "        \n",
    "        Args:\n",
    "            threshold: Threshold for bar formation (number of ticks, volume, or dollar amount)\n",
    "        \"\"\"\n",
    "        self.threshold = threshold\n",
    "        self.reset()\n",
    "    \n",
    "    def reset(self):\n",
    "        \"\"\"Reset internal state for new bar formation\"\"\"\n",
    "        self.bars = []\n",
    "        self.current_bar = {\n",
    "            'timestamp': None,\n",
    "            'open': None,\n",
    "            'high': None,\n",
    "            'low': None,\n",
    "            'close': None,\n",
    "            'volume': 0,\n",
    "            'tick_count': 0,\n",
    "            'dollar_volume': 0,\n",
    "            'vwap': 0\n",
    "        }\n",
    "        self.accumulated_value = 0\n",
    "        self.vwap_numerator = 0\n",
    "    \n",
    "    def _update_current_bar(self, timestamp: pd.Timestamp, price: float, volume: float):\n",
    "        \"\"\"Update the current bar with new tick data\"\"\"\n",
    "        if self.current_bar['open'] is None:\n",
    "            # First tick of the bar\n",
    "            self.current_bar['timestamp'] = timestamp\n",
    "            self.current_bar['open'] = price\n",
    "            self.current_bar['high'] = price\n",
    "            self.current_bar['low'] = price\n",
    "        else:\n",
    "            # Update OHLC\n",
    "            self.current_bar['high'] = max(self.current_bar['high'], price)\n",
    "            self.current_bar['low'] = min(self.current_bar['low'], price)\n",
    "        \n",
    "        self.current_bar['close'] = price\n",
    "        self.current_bar['volume'] += volume\n",
    "        self.current_bar['tick_count'] += 1\n",
    "        \n",
    "        dollar_vol = price * volume\n",
    "        self.current_bar['dollar_volume'] += dollar_vol\n",
    "        self.vwap_numerator += dollar_vol\n",
    "        \n",
    "        # Calculate VWAP\n",
    "        if self.current_bar['volume'] > 0:\n",
    "            self.current_bar['vwap'] = self.vwap_numerator / self.current_bar['volume']\n",
    "    \n",
    "    def _finalize_bar(self) -> dict:\n",
    "        \"\"\"Finalize current bar and prepare for next one\"\"\"\n",
    "        completed_bar = self.current_bar.copy()\n",
    "        \n",
    "        # Reset for next bar\n",
    "        self.current_bar = {\n",
    "            'timestamp': None,\n",
    "            'open': None,\n",
    "            'high': None,\n",
    "            'low': None,\n",
    "            'close': None,\n",
    "            'volume': 0,\n",
    "            'tick_count': 0,\n",
    "            'dollar_volume': 0,\n",
    "            'vwap': 0\n",
    "        }\n",
    "        self.accumulated_value = 0\n",
    "        self.vwap_numerator = 0\n",
    "        \n",
    "        return completed_bar\n",
    "\n",
    "class TickBars(FinancialBars):\n",
    "    \"\"\"\n",
    "    Form bars based on number of ticks\n",
    "    \"\"\"\n",
    "    \n",
    "    def add_tick(self, timestamp: pd.Timestamp, price: float, volume: float) -> Optional[dict]:\n",
    "        \"\"\"\n",
    "        Add a tick and return completed bar if threshold reached\n",
    "        \n",
    "        Args:\n",
    "            timestamp: Tick timestamp\n",
    "            price: Tick price\n",
    "            volume: Tick volume\n",
    "            \n",
    "        Returns:\n",
    "            Completed bar dict if threshold reached, None otherwise\n",
    "        \"\"\"\n",
    "        self._update_current_bar(timestamp, price, volume)\n",
    "        self.accumulated_value += 1\n",
    "        \n",
    "        if self.accumulated_value >= self.threshold:\n",
    "            completed_bar = self._finalize_bar()\n",
    "            self.bars.append(completed_bar)\n",
    "            return completed_bar\n",
    "        \n",
    "        return None\n",
    "\n",
    "class VolumeBars(FinancialBars):\n",
    "    \"\"\"\n",
    "    Form bars based on volume\n",
    "    \"\"\"\n",
    "    \n",
    "    def add_tick(self, timestamp: pd.Timestamp, price: float, volume: float) -> Optional[dict]:\n",
    "        \"\"\"\n",
    "        Add a tick and return completed bar if volume threshold reached\n",
    "        \"\"\"\n",
    "        self._update_current_bar(timestamp, price, volume)\n",
    "        self.accumulated_value += volume\n",
    "        \n",
    "        if self.accumulated_value >= self.threshold:\n",
    "            completed_bar = self._finalize_bar()\n",
    "            self.bars.append(completed_bar)\n",
    "            return completed_bar\n",
    "        \n",
    "        return None\n",
    "\n",
    "class DollarBars(FinancialBars):\n",
    "    \"\"\"\n",
    "    Form bars based on dollar volume\n",
    "    \"\"\"\n",
    "    \n",
    "    def add_tick(self, timestamp: pd.Timestamp, price: float, volume: float) -> Optional[dict]:\n",
    "        \"\"\"\n",
    "        Add a tick and return completed bar if dollar volume threshold reached\n",
    "        \"\"\"\n",
    "        self._update_current_bar(timestamp, price, volume)\n",
    "        dollar_volume = price * volume\n",
    "        self.accumulated_value += dollar_volume\n",
    "        \n",
    "        if self.accumulated_value >= self.threshold:\n",
    "            completed_bar = self._finalize_bar()\n",
    "            self.bars.append(completed_bar)\n",
    "            return completed_bar\n",
    "        \n",
    "        return None\n",
    "\n",
    "class ETFRollAdjustment:\n",
    "    \"\"\"\n",
    "    ETF trick for futures roll adjustment as described in AFML\n",
    "    \n",
    "    The idea is to use price ratios from an ETF that tracks the same underlying\n",
    "    to adjust for futures contract rolls, avoiding the gaps that occur during\n",
    "    contract switches.\n",
    "    \"\"\"\n",
    "    \n",
    "    def __init__(self, futures_data: pd.DataFrame, etf_data: pd.DataFrame):\n",
    "        \"\"\"\n",
    "        Initialize roll adjustment\n",
    "        \n",
    "        Args:\n",
    "            futures_data: DataFrame with futures prices (timestamp, price columns)\n",
    "            etf_data: DataFrame with ETF prices (timestamp, price columns)\n",
    "        \"\"\"\n",
    "        self.futures_data = futures_data.copy()\n",
    "        self.etf_data = etf_data.copy()\n",
    "        \n",
    "        # Ensure both datasets are sorted by timestamp\n",
    "        self.futures_data = self.futures_data.sort_values('timestamp')\n",
    "        self.etf_data = self.etf_data.sort_values('timestamp')\n",
    "    \n",
    "    def detect_roll_dates(self, price_change_threshold: float = 0.1) -> List[pd.Timestamp]:\n",
    "        \"\"\"\n",
    "        Detect futures roll dates by identifying large price gaps\n",
    "        \n",
    "        Args:\n",
    "            price_change_threshold: Minimum price change (as fraction) to consider a roll\n",
    "            \n",
    "        Returns:\n",
    "            List of timestamps where rolls likely occurred\n",
    "        \"\"\"\n",
    "        futures_returns = self.futures_data['price'].pct_change().abs()\n",
    "        roll_candidates = self.futures_data[futures_returns > price_change_threshold]['timestamp'].tolist()\n",
    "        \n",
    "        return roll_candidates\n",
    "    \n",
    "    def adjust_prices(self, roll_dates: Optional[List[pd.Timestamp]] = None) -> pd.DataFrame:\n",
    "        \"\"\"\n",
    "        Adjust futures prices using ETF price ratios\n",
    "        \n",
    "        Args:\n",
    "            roll_dates: List of roll dates. If None, will auto-detect\n",
    "            \n",
    "        Returns:\n",
    "            DataFrame with adjusted futures prices\n",
    "        \"\"\"\n",
    "        if roll_dates is None:\n",
    "            roll_dates = self.detect_roll_dates()\n",
    "        \n",
    "        # Merge futures and ETF data on timestamp (using nearest match)\n",
    "        merged = pd.merge_asof(\n",
    "            self.futures_data.sort_values('timestamp'),\n",
    "            self.etf_data.sort_values('timestamp'),\n",
    "            on='timestamp',\n",
    "            suffixes=('_futures', '_etf'),\n",
    "            direction='nearest'\n",
    "        )\n",
    "        \n",
    "        # Calculate ETF returns\n",
    "        merged['etf_returns'] = merged['price_etf'].pct_change()\n",
    "        \n",
    "        adjusted_prices = merged['price_futures'].copy()\n",
    "        \n",
    "        # Apply roll adjustments\n",
    "        for roll_date in roll_dates:\n",
    "            roll_idx = merged[merged['timestamp'] >= roll_date].index\n",
    "            \n",
    "            if len(roll_idx) > 0:\n",
    "                roll_start = roll_idx[0]\n",
    "                \n",
    "                if roll_start > 0:\n",
    "                    # Get the price jump in futures\n",
    "                    pre_roll_price = merged.loc[roll_start - 1, 'price_futures']\n",
    "                    post_roll_price = merged.loc[roll_start, 'price_futures']\n",
    "                    \n",
    "                    # Get corresponding ETF prices\n",
    "                    pre_roll_etf = merged.loc[roll_start - 1, 'price_etf']\n",
    "                    post_roll_etf = merged.loc[roll_start, 'price_etf']\n",
    "                    \n",
    "                    # Calculate adjustment factor using ETF ratio\n",
    "                    if pre_roll_etf != 0 and post_roll_etf != 0:\n",
    "                        etf_ratio = post_roll_etf / pre_roll_etf\n",
    "                        expected_futures_price = pre_roll_price * etf_ratio\n",
    "                        adjustment = expected_futures_price - post_roll_price\n",
    "                        \n",
    "                        # Apply adjustment to all prices from roll date onwards\n",
    "                        adjusted_prices.iloc[roll_start:] += adjustment\n",
    "        \n",
    "        result = merged[['timestamp']].copy()\n",
    "        result['original_price'] = merged['price_futures']\n",
    "        result['adjusted_price'] = adjusted_prices\n",
    "        result['etf_price'] = merged['price_etf']\n",
    "        \n",
    "        return result\n",
    "\n",
    "def create_bars_with_etf_adjustment(tick_data: pd.DataFrame, \n",
    "                                   etf_data: pd.DataFrame,\n",
    "                                   bar_type: str = 'volume',\n",
    "                                   threshold: Union[int, float] = 1000) -> pd.DataFrame:\n",
    "    \"\"\"\n",
    "    Complete workflow: ETF roll adjustment + bar formation\n",
    "    \n",
    "    Args:\n",
    "        tick_data: DataFrame with columns ['timestamp', 'price', 'volume']\n",
    "        etf_data: DataFrame with columns ['timestamp', 'price']\n",
    "        bar_type: 'tick', 'volume', or 'dollar'\n",
    "        threshold: Threshold for bar formation\n",
    "        \n",
    "    Returns:\n",
    "        DataFrame with formed bars\n",
    "    \"\"\"\n",
    "    # Step 1: Apply ETF roll adjustment\n",
    "    roll_adjuster = ETFRollAdjustment(\n",
    "        tick_data[['timestamp', 'price']].copy(),\n",
    "        etf_data.copy()\n",
    "    )\n",
    "    adjusted_data = roll_adjuster.adjust_prices()\n",
    "    \n",
    "    # Step 2: Merge adjusted prices back with volume data\n",
    "    adjusted_ticks = pd.merge(\n",
    "        tick_data[['timestamp', 'volume']],\n",
    "        adjusted_data[['timestamp', 'adjusted_price']],\n",
    "        on='timestamp'\n",
    "    ).rename(columns={'adjusted_price': 'price'})\n",
    "    \n",
    "    # Step 3: Form bars\n",
    "    if bar_type.lower() == 'tick':\n",
    "        bar_former = TickBars(threshold)\n",
    "    elif bar_type.lower() == 'volume':\n",
    "        bar_former = VolumeBars(threshold)\n",
    "    elif bar_type.lower() == 'dollar':\n",
    "        bar_former = DollarBars(threshold)\n",
    "    else:\n",
    "        raise ValueError(\"bar_type must be 'tick', 'volume', or 'dollar'\")\n",
    "    \n",
    "    bars = []\n",
    "    for _, row in adjusted_ticks.iterrows():\n",
    "        completed_bar = bar_former.add_tick(row['timestamp'], row['price'], row['volume'])\n",
    "        if completed_bar is not None:\n",
    "            bars.append(completed_bar)\n",
    "    \n",
    "    return pd.DataFrame(bars)\n",
    "\n",
    "# Example usage\n",
    "if __name__ == \"__main__\":\n",
    "    # Example with synthetic data\n",
    "    np.random.seed(42)\n",
    "    \n",
    "    # Create synthetic futures tick data\n",
    "    n_ticks = 10000\n",
    "    timestamps = pd.date_range('2024-01-01', periods=n_ticks, freq='1min')\n",
    "    \n",
    "    # Simulate prices with a roll gap\n",
    "    base_price = 100\n",
    "    prices = [base_price]\n",
    "    \n",
    "    for i in range(1, n_ticks):\n",
    "        # Add a large gap at tick 5000 to simulate roll\n",
    "        if i == 5000:\n",
    "            prices.append(prices[-1] + 20)  # Roll gap\n",
    "        else:\n",
    "            change = np.random.normal(0, 0.1)\n",
    "            prices.append(max(prices[-1] + change, 1))\n",
    "    \n",
    "    volumes = np.random.exponential(100, n_ticks)\n",
    "    \n",
    "    futures_data = pd.DataFrame({\n",
    "        'timestamp': timestamps,\n",
    "        'price': prices,\n",
    "        'volume': volumes\n",
    "    })\n",
    "    \n",
    "    # Create synthetic ETF data (no roll gaps)\n",
    "    etf_prices = [base_price]\n",
    "    for i in range(1, n_ticks):\n",
    "        change = np.random.normal(0, 0.08)  # Slightly less volatile\n",
    "        etf_prices.append(max(etf_prices[-1] + change, 1))\n",
    "    \n",
    "    etf_data = pd.DataFrame({\n",
    "        'timestamp': timestamps,\n",
    "        'price': etf_prices\n",
    "    })\n",
    "    \n",
    "    # Form volume bars with ETF roll adjustment\n",
    "    volume_bars = create_bars_with_etf_adjustment(\n",
    "        futures_data, \n",
    "        etf_data, \n",
    "        bar_type='volume', \n",
    "        threshold=5000\n",
    "    )\n",
    "    \n",
    "    print(f\"Created {len(volume_bars)} volume bars\")\n",
    "    print(\"\\nFirst 5 bars:\")\n",
    "    print(volume_bars.head())\n",
    "    \n",
    "    # Form dollar bars\n",
    "    dollar_bars = create_bars_with_etf_adjustment(\n",
    "        futures_data,\n",
    "        etf_data,\n",
    "        bar_type='dollar',\n",
    "        threshold=500000\n",
    "    )\n",
    "    \n",
    "    print(f\"\\nCreated {len(dollar_bars)} dollar bars\")\n",
    "    \n",
    "    # Form tick bars\n",
    "    tick_bars = create_bars_with_etf_adjustment(\n",
    "        futures_data,\n",
    "        etf_data,\n",
    "        bar_type='tick',\n",
    "        threshold=100\n",
    "    )\n",
    "    \n",
    "    print(f\"\\nCreated {len(tick_bars)} tick bars\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "name": "python",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
